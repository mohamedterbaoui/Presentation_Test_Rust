<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />

    <title>reveal.js</title>

    <link rel="stylesheet" href="dist/reset.css" />
    <link rel="stylesheet" href="dist/reveal.css" />
    <link rel="stylesheet" href="dist/theme/dracula.css" />

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="plugin/highlight/monokai.css" />
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <!-- Slide 1 : Titre -->
        <section>
          <h1>Tests Unitaires en Rust</h1>
          <p><small>Mohamed Terbaoui | IFT3913 | 19 Septembre 2025</small></p>
          <small>Made with <a href="https://revealjs.com/">Reveal.js</a></small>
        </section>

        <!-- Slide 2 : Plan -->
        <section>
          <h3>Plan</h3>
          <ol>
            <li>Introduction : pourquoi les tests ?</li>
            <li>Rust en bref</li>
            <li>Les tests en Rust</li>
            <li>Exemples de tests unitaires en Rust</li>
            <li>D√©mo interactive</li>
            <li>Point original</li>
            <li>R√©flexion</li>
            <li>Conclusion & Sources</li>
          </ol>
        </section>

        <!-- Slide 3 : Importance des tests -->
        <section>
          <h3>1. Pourquoi les tests en Rust ?</h3>
          <img
            src="examples\assets\meme.png"
            alt="funny-meme"
            style="width: 400px"
          />
          <ul style="font-size: 1.7rem">
            <li>
              Rust offre la s√©curit√© m√©moire, mais les tests assurent la logique
              m√©tier
            </li>
            <li>
              Assurer le fonctionnement correct des fonctions avec
              <a href="https://doc.rust-lang.org/nomicon/ownership.html"
                >ownership et lifetimes</a
              >
            </li>
            <li>
              V√©rifier le comportement des fonctions qui utilisent des threads
              ou async
            </li>
          </ul>
        </section>

        <section>
          <!-- Slide 4 : Rust en bref -->
          <section>
            <h3>2. Rust en bref</h3>
            <ul>
              <li>Cr√©√© en 2010 chez <b>Mozilla</b></li>
              <li>S√©curit√© m√©moire <b>sans garbage collector</b></li>
              <li>Performance proche de C/C++</li>
              <li>Utilisations : syst√®mes, Web, blockchain</li>
            </ul>
          </section>

          <section>
            <h3>Points forts de Rust</h3>
            <ul>
              <li>üõ°Ô∏è S√©curit√© m√©moire (ownership, borrow checker)</li>
              <li>‚ö° Performance bas niveau</li>
              <li>üîÄ Concurrence s√ªre</li>
            </ul>
          </section>
        </section>

        <!--Slide 5 : Tests unitaires en rust -->

        <section>
          <section>
            <h3>3. Les Tests unitaires en Rust</h3>

            <p>
              Les tests en Rust sont tr√®s simples √† impl√©menter car ils sont
              <b>inclus par d√©faut</b> dans le gestionnaire de paquets
              <code>cargo</code>.
            </p>

            <ul>
              <li>Pas besoin d‚Äôinstaller un framework externe</li>
              <li>Un test = une fonction annot√©e avec <code>#[test]</code></li>
              <li>Ex√©cution avec la commande <code>cargo test</code></li>
              <li>
                En g√©n√©ral, les tests unitaires se trouvent dans le m√™me fichier
                que le code.
              </li>
            </ul>
          </section>
          <section data-auto-animate>
            <h3 data-id="code-title">
              Syntaxe d'un test unitaire simple en RUST
            </h3>
            <pre
              data-id="code-animation"
            ><code class="language-rust" data-trim data-line-numbers="|1-4|6-10"><script type="text/template">
    // Fonction √† tester
    fn add(a: i32, b: i32) -> i32 {
        a + b
    }

    // Test unitaire de la fonction
    #[test]
    fn test_add() {
        assert_eq!(add(2, 2), 4); // V√©rifie que 2+2 = 4
    }
					</script></code></pre>
            <p>
              <i> Cargo compile et ex√©cute automatiquement tous les tests.</i>
            </p>
          </section>
          <section>
            Pour tester un seul test avec cargo :
            <pre><code class="language-rust">
          cargo test Nom_du_test
            </code></pre>
          </section>
        </section>

        <section>
          <section>
            <h3>4. Exemples de tests unitaires en Rust</h3>
            <ul>
              <li>
                Tests classiques avec <code>assert_eq!</code> et
                <code>assert!</code>
              </li>
              <li>
                Tests qui doivent √©chouer avec <code>#[should_panic]</code>
              </li>
              <li>Tests avec messages d‚Äôerreur personnalis√©s</li>
              <li>
                Organisation avec <code>#[cfg(test)] mod tests { ... }</code>
              </li>
            </ul>
          </section>

          <section>
            <h3>Exemple : Test d‚Äô√©chec attendu</h3>
            <pre><code class="language-rust">
    // Fonction qui panique si n == 0
    fn divide(a: i32, b: i32) -> i32 {
        if b == 0 {
            panic!("Division par z√©ro !");
        }
        a / b
    }

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        #[should_panic(expected = "Division par z√©ro")]
        fn test_divide_by_zero() {
            divide(10, 0);
        }
    }
  </code></pre>
            <div
              style="
                background: #424f5c;
                color: white;
                padding: 10px;
                border-radius: 8px;
                margin-top: 10px;
                font-size: 0.7em;
              "
            >
              üí° <b>Note :</b> En Rust, <code>panic!</code> stoppe imm√©diatement
              l‚Äôex√©cution du programme. On l‚Äôutilise pour signaler des erreurs
              irr√©parables (ex. division par z√©ro).
            </div>
          </section>

          <section>
            <h3>Exemple : Messages personnalis√©s</h3>
            <pre><code class="language-rust">
    fn is_even(n: i32) -> bool {
        n % 2 == 0
    }

    #[test]
    fn test_is_even() {
        let value = 3;
        assert!(is_even(value), "{} n'est pas pair !", value);
    }
  </code></pre>
            <p style="color: gray; font-size: 0.9em">
              Les messages personnalis√©s rendent les erreurs plus claires : ici,
              on sait quel nombre a √©chou√© au test.
            </p>
          </section>
          <section>
            <h3>Tests avec Result&lt;T, E&gt; et gestion d'erreurs</h3>
            <pre><code class="language-rust">     
    use std::fs::File;
    use std::io::Error;

    fn read_file_size(path: &str) -> Result&lt;u64, Error&gt; {
        let file = File::open(path)?;
        Ok(file.metadata()?.len())
    }

    #[cfg(test)]
    mod tests {
        use super::*;
        
        #[test]
        fn test_file_exists() -> Result&lt;(), Error&gt; {
            // Test qui retourne un Result
            let size = read_file_size("Cargo.toml")?;
            assert!(size > 0);
            Ok(())
        }
        
        #[test]
        fn test_file_not_found() {
            let result = read_file_size("fichier_inexistant.txt");
            assert!(result.is_err());
        }
    }

  </code></pre>
            <p style="color: gray; font-size: 0.5em">
              test_file_exists() : Ce test v√©rifie qu'un fichier existant
              (Cargo.toml) peut √™tre lu et a une taille > 0. Le test r√©ussit si
              le fichier existe et peut √™tre lu, √©choue si le fichier n'existe
              pas ou est inaccessible. test_file_not_found() : Ce test v√©rifie
              que la fonction retourne bien une erreur quand on essaie de lire
              un fichier inexistant. Le test r√©ussit si result.is_err() est
              vrai, confirmant que la gestion d'erreur fonctionne correctement.
            </p>
          </section>

          <section>
            <h3>Tests ignor√©s et conditionnels</h3>
            <pre><code class="language-rust">     
    #[test]
    #[ignore = "Test lent, √† ex√©cuter manuellement"]
    fn test_performance_long() {
        std::thread::sleep(std::time::Duration::from_secs(5));
        assert_eq!(2 + 2, 4);
    }

    #[test]
    #[cfg(target_os = "linux")]
    fn test_linux_only() {
        // Ce test ne s'ex√©cute que sur Linux
        assert!(std::path::Path::new("/proc").exists());
    }

  </code></pre>
            <p style="color: gray; font-size: 0.5em">
              test_performance_long() : Ce test simule un processus long (5
              secondes) mais est ignor√© par d√©faut pour ne pas ralentir les
              tests r√©guliers. Il faut l'ex√©cuter manuellement avec cargo test
              -- --ignored quand on veut tester les performances.
              test_linux_only() : Ce test ne s'ex√©cute que sur les syst√®mes
              Linux et v√©rifie l'existence du dossier /proc. Il sera ignor√©
              automatiquement sur Windows/macOS, permettant d'avoir du code
              sp√©cifique √† certaines plateformes.
            </p>
          </section>

          <section>
            <h3>Tests param√©tr√©s avec macros</h3>
            <pre><code class="language-rust">     
    fn is_prime(n: u32) -> bool {
        if n &lt; 2 { return false; }
        for i in 2..=(n as f64).sqrt() as u32 {
            if n % i == 0 { return false; }
        }
        true
    }

    macro_rules! test_primes {
        ($($name:ident: $value:expr,)*) => {
            $(
                #[test]
                fn $name() {
                    let (input, expected) = $value;
                    assert_eq!(is_prime(input), expected);
                }
            )*
        }
    }

    test_primes! {
        test_2_is_prime: (2, true),
        test_4_not_prime: (4, false),
        test_17_is_prime: (17, true),
    }

  </code></pre>
            <p style="color: gray; font-size: 0.5em">
              test_primes (macro) : Cette macro g√©n√®re automatiquement plusieurs
              tests pour v√©rifier si diff√©rents nombres sont premiers ou non.
              Elle √©vite la r√©p√©tition de code en cr√©ant des tests
              test_2_is_prime, test_4_not_prime, etc. avec le m√™me pattern.
            </p>
          </section>
        </section>

        <!-- Slide 7 : D√©mo interactive -->
        <section>
          <h3>5. D√©mo interactive</h3>
          <p>Ex√©cution des tests dans le Rust Playground :</p>
          <iframe
            src="https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&code=fn%20add(a%3A%20i32%2C%20b%3A%20i32)%20-%3E%20i32%20%7B%0A%20%20%20%20a%20%2B%20b%0A%7D%0A%0A%23%5Btest%5D%0Afn%20test_add()%20%7B%0A%20%20%20%20assert_eq!(add(2%2C%202)%2C%204)%3B%0A%7D"
            width="100%"
            height="400px"
          >
          </iframe>
          <p><i>Cliquez sur "Run" pour lancer le test</i></p>
        </section>

        <!-- Slide 8 : Point original -->
        <section>
          <h3>6. Quelques concepts propres √† RUST</h3>
          <ul>
            <li>
              Rust permet des <b>tests de panique</b> ‚Üí valider les erreurs
              attendues
            </li>
            <li>
              Outils externes : <code>cargo tarpaulin</code> pour la couverture
            </li>
            <li>Benchmarking avec <code>criterion</code></li>
          </ul>
        </section>

        <!-- Slide 9 : R√©flexion -->
        <section>
          <h3>7. R√©flexion</h3>
          <p>
            üîπ Java ‚Üí JUnit (framework externe)<br />
            üîπ Python ‚Üí PyTest / Unittest (externes)<br />
            üîπ Rust ‚Üí tests int√©gr√©s avec Cargo ‚Üí <b>plus simple et robuste</b>
          </p>
          <p>
            <i
              >Rust combine s√©curit√© m√©moire et tests int√©gr√©s pour une qualit√©
              logicielle √©lev√©e</i
            >
          </p>
        </section>

        <!-- Slide 10 : Conclusion -->
        <section>
          <h3>8. Conclusion</h3>
          <p style="font-size: 1em; text-align: center">
            Tester dans Rust est <b>simple</b>, <b>rapide</b> et
            <b>pratique</b> gr√¢ce √† des <b>assertions avanc√©es</b> int√©gr√©es. Un
            outil essentiel pour garantir la <b>qualit√© logicielle</b>.
          </p>
          <h3>Sources</h3>

          <ul>
            <li><a href="https://doc.rust-lang.org/cargo/">Cargo Book</a></li>
            <li>
              <a href="https://doc.rust-lang.org/rust-by-example/testing.html"
                >Rust by Example ‚Äì Testing</a
              >
            </li>
            <li>
              <a href="https://foundation.rust-lang.org/">Rust Foundation</a>
            </li>
          </ul>
        </section>

        <!-- Questions -->
        <section>
          <h1>Des questions*?</h1>
          <h6 style="font-size: 1rem; color: white">
            *(Sauf si c‚Äôest sur le borrow checker ü¶Ä)
          </h6>
        </section>
      </div>
    </div>

    <script src="dist/reveal.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
    <script>
      // More info about initialization & config:
      // - https://revealjs.com/initialization/
      // - https://revealjs.com/config/
      Reveal.initialize({
        hash: true,

        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [RevealMarkdown, RevealHighlight, RevealNotes],
      });
    </script>
  </body>
</html>
